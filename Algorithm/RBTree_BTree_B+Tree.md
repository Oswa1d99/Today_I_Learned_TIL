### 트리

트리는 **계층적인 데이터를 표현하고, 특정 조건 하에서 탐색, 삽입 그리고 삭제를 효율적으로 수행한다**는 점에서 장점이 있는 자료구조다.  
그 중에서, (1. 최대 2개의 자식 노드를 가지고, 2. 왼쪽 자식 노드 < 현재 노드 < 오른쪽 자식 노드)의 규칙을 따르는 이진 탐색 트리(BST)는 데이터를 정렬된 상태로 다루면서도,  
평균적으로 O(logN)의 시간 복잡도로 탐색이 가능하다는 점에서 자주 사용되는 트리다.  
> 물론, 탐색에 대해서 O(1)의 시간복잡도로 가능한 해시 테이블이 존재하지만 BST는 정렬된 자료구조이기에 범위 검색(>, <, BETWEEN)에 유리하다.
> 
> 또한 후술할 자가 균형 트리를 사용한다면 최악의 상황에서도 O(logN)을 보장하기 때문에, 해시 충돌 시 O(N)으로 성능 하락이 발생하는 해시 테이블에 비해 예측 가능성과 안정성이 더 높다.
> 

하지만, BST를 만들 때 이미 정렬된 배열을 입력하게 되면 최악의 상황이 발생한다.   
트리가 한 쪽으로만 편향(skewed)되어 길어지는 현상이 나타나는데,  
이 경우 트리는 사실 상 연결 리스트와 다를 바가 없게 되어 탐색 속도가 O(N)으로 치솟는다.  

이를 위해서는 한 쪽으로만 트리가 길어지는 현상을 방지할 수 있도록 균형을 동적으로 맞춰줘야 하고, 이러한 트리를 **자가 균형 트리**라고 일컫는다.  

### RB 트리

자가 균형 트리 중 자가 균형 이진 탐색 트리의 대표주자인 RB 트리는 모든 노드가 Red 혹은 Black에 해당한다.  
RB 트리는 다음과 같은 5가지 규칙을 통해 **가장 긴 경로가 가장 짧은 경로의 2배를 넘지 않게 강제함**으로써 트리의 균형을 유지한다.  

1. 모든 노드는 레드 혹은 블랙이다.
2. 루트 노드는 블랙이다.
3. 모든 리프 노드는 NIL 노드이며 블랙 노드이다.
4. 레드 노드는 레드 노드를 자식으로 가질 수 없다 (= 레드 노드는 연속으로 존재할 수 없다)
5. 임의의 한 노드에서 NIL 노드까지 도달하는 모든 경로에는 항상 블랙 노드의 수가 같다.

4번과 5번 조건에 의해서, 루트 노드부터 리프까지 가는 경로 중 
- 가장 짧은 경로 = N개의 블랙 노드만으로 이루어진 경로  
- 가장 긴 경로 = N개의 블랙 노드 사이사이에 레드 노드(N-1개)가 있는 경로
이기 때문에 가장 긴 경로(2N-1)은 가장 짧은 경로(N)의 2배 이하를 유지한다.

이로 인해, 트리는 높이가 계속 커지는 방향으로만 성장할 수는 없으며 반드시 여러 자식 노드를 통해 옆으로도 성장을 해야한다.  
즉, 트리의 높이에 의해 탐색/삭제/삽입의 시간 복잡도가 결정되는 트리 자료구조의 특성 상, 높이가 안정적으로 유지될 수 있는 것이다.  

> 또다른 자가 균형 이진 탐색 트리로 AVL 트리가 존재한다.
> 
> AVL 트리는 더 엄격한 균형 전략을 통해, 높이를 더 낮게 유지하여 탐색 시간이 RB 트리에 비해 빠르다.  
> 하지만 삽입, 삭제 시 균형을 맞추기 위한 회전이 더 많이 발생하여 쓰기 위주의 작업에는 불리하다.  

### B 트리

`/users/home/`과 같은 계층적 구조의 파일 시스템을 트리로 표현할 수 있다는 점은 자연스럽다.  
그렇다면, `/users/home/` 안의 데이터를 BST나 RB 트리를 이용해 접근한다고 생각해보자.  

BST나 RB 트리와 같은 이진 트리는 기본적으로 하나의 노드에 하나의 데이터만을 저장하기 때문에, 디스크 안의 데이터에게 접근하려면 굉장히 많은 입출력 연산이 필요하다.  
실제로 디스크의 파일을 접근할 때는 한 번에 덩어리 단위의 여러 데이터에 접근하기 때문에 이진 탐색 트리는 부적합하다.  
하지만 B 트리와 같은 **다진 탐색 트리**는 하나의 노드에 여러 (키, 밸류)를 가질 수 있기 때문에 적은 디스크 I/O 만으로도 가능하다.  

B트리의 각 노드는 여러 Key와 Value, Pointer를 가진다.  
<img width="600" height="200" alt="image" src="https://github.com/user-attachments/assets/01a7e86c-069a-4342-a470-160e9a79550a" />

파일시스템에서의 작동 예시를 통해 이해해보자.  
- Key: `/photos/cat.jpg`, `/photos/dog.png`와 같은 파일이나 디렉터리 이름이 Key가 된다. 노드 내에서 Key는 **항상 정렬된 상태**를 유지한다.  
- Value: 각 Key에 해당하는 아이노드(Inode) 번호가 저장된다. 아이노드는 파일의 메타데이터와 실제 데이터가 저장된 디스크 위치를 가리키는 일종의 포인터 역할을 수행한다.  
- Pointer: Key 값들을 기준으로 정렬된 하위 노드들을 가리킨다.  노드에 Key가 N개 있다면 Pointer는 항상 N+1개 존재하며, 각 포인터는 Key 값 사이의 범위를 담당한다고 이해하자.
    - 예를 들어 `cat.jpg`와 `dog.jpg`라는 2개의 Key를 가진 노드는 3개의 포인터를 갖는다. 첫 포인터는 cat.jpg보다 이름이 앞서는 파일들의 노드를, 두 번째 포인터는 둘 사이의 파일들을, 마지막 포인터는 dog.jpg보다 이름이 뒤에 오는 파일들의 노드를 가리키게 된다.

하나의 노드가 많은 데이터(키)를 가질 수 있고, 키 개수에 비례하는 포인터를 통해 많은 자식 노드를 표현할 수 있어, 이진 탐색 트리보다 트리의 높이가 매우 낮게 유지되는 장점이 있다.  
앞서 언급했듯이, 트리의 탐색 작업 시간은 트리의 높이에 반비례하므로, 높이가 낮은 B 트리는 적은 디스크 I/O 작업만으로 원하는 데이터를 탐색할 수 있다.  

### B+ 트리

B+ 트리는 B 트리의 변형 버전으로, 다음과 같은 특징을 가진다.  
1. 데이터는 오직 리프 노드에만 저장된다.
2. 모든 리프 노드는 연결 리스트 형태로 연결되어 있다.

기존 B 트리에는 각 노드가 Key와 Value를 모두 가지고 있었다.  
하지만, 노드의 크기는 제한되어 있어 Value가 차지하는 메모리 공간으로 인해 대단히 많은 수의 Key 값을 노드에 저장하기는 어려웠다.  
이로 인해 하나의 노드가 가질 수 있는 키의 개수는 제한되어 있었다.  

B+ 트리는 각 노드에 Key와 Pointer만 저장하고, Value는 리프 노드에만 저장함으로써 이를 개선한다.  
Value가 차지하던 공간에 더 많은 Key를 저장함으로써, 하나의 노드가 훨씬 더 많은 자식 노드를 가질 수 있다.  
이로 인해, 분기 계수가 높아져 트리의 높이가 낮아짐으로써 공간 효율성을 확보하였다.  

또한, 데이터를 정렬된 연결 리스트 형태로 구현함으로써 데이터베이스에서 자주 사용되는 범위 탐색에 매우 유리하다.  
B+ 트리에서는 리프 노드에서 시작점을 찾고, 선형 탐색만으로도 처리가 가능해 효율적이다.  (B 트리의 경우, 트리를 반복적으로 오르내려야 한다.)
이러한 특징들 덕분에, MySQL과 같은 데이터베이스의 인덱스로 B+ 트리가 사용된다.    

## 백트래킹

백트래킹(Backtracking)은 해를 찾는 도중, 현재 경로가 더 이상 유망하지 않다고 판단되면 이전으로 되돌아가 다른 경로를 탐색하는 문제 해결 전략이다.  
트리로 주어지거나, 트리 형태로 간주할 수 있는(eg. 2차원 배열) 모든 상황에 적용 가능하다.  

흔히 DFS(깊이 우선 탐색)와 비교되는데, 백트래킹은 가지치기(Pruning)가 적용된 DFS라고 생각하면 이해하기 수월하다. 
DFS가 모든 경로를 끝까지 탐색하는 완전 탐색 알고리즘이라면, 백트래킹은 '유망성 검사(Promising Check)'를 통해 불필요한 경로를 조기에 차단한다.

<img width="500" height="300" alt="image" src="https://github.com/user-attachments/assets/a8f302ea-6e22-4c30-84b7-6253327ffde0" />

n-Queens, 부분집합의 합, 0-1 배낭문제 등의 많은 문제에서 완전 탐색을 사용한다면 시간 초과 판정을 받기 십상이다.  
따라서 모든 리프 노드까지 탐색할 필요 없이, 특정 경로가 해가 될 가능성이 없다고 판단되면(Not Promising) 그 하위 트리 전체를 탐색 대상에서 제외하고 이전 선택 지점으로 되돌아가는(Backtrack) 전략을 차용하는 것이 '해결' 판정을 받는 데 필수적이다.

이처럼 백트래킹은 DFS를 기반으로 해 구현의 기본 구조는 단순하지만, 문제의 제약 조건을 정확히 반영하여 '가지치기' 기능을 수행하는 **유망성 검사(Promising) 함수의 논리를 설계**하는 것이 핵심이자 가장 까다로운 부분이다.  

백트래킹을 대표하는 문제 몇몇을 풀어보면서, 그 개념을 익혀보자.

---

### N-Queens (백준 9663)
N X N 사이즈의 체스판에서 행/열/대각선 방향으로 체스판 끝까지 이동이 가능한 퀸 N개를 동선 상 겹치지 않게 두는 문제이다.  

이 문제를 해결하는 가장 단순한 논리적 흐름은 다음과 같다:  
> 퀸을 하나씩 두면서, 이전 퀸의 행/열/대각선 방향과 겹치지 않는지 확인한다

이 문제를 가장 단순하게 접근하면, N X N개의 칸 중 퀸을 놓을 N개의 칸을 선택하는 모든 조합을 확인하는 것이다.
4-Queens의 경우 16개의 칸 중 4개를 선택하는 것이므로, 총 16C4 = 1,820가지의 경우를 모두 확인해야 한다.  

하지만 여기서 문제의 제약 조건을 활용한 '작은 트릭'이 유용하게 쓰인다.  
바로 **어차피 각 행에는 퀸이 반드시 하나만 존재한다**는 사실을 이용해, 탐색의 구조 자체를 바꾸는 것이다. 
즉, "어떤 칸에 놓을까?"가 아니라 "1번 행에는 몇 열에 놓을까?", "2번 행에는 몇 열에 놓을까?" 로 문제를 재정의한다.

이렇게 하면 각 행마다 N개의 열 중 하나를 선택하는 문제가 되므로, 탐색 공간의 크기가 대략 N^N수준으로 줄어듭니다. 4-Queens의 경우 4^4 = 256가지로, 
1,820가지에 비해 경우의 수가 크게 감소한다.
백트래킹은 이 256가지의 가능성 속에서 유망하지 않은 경로를 더 쳐내는 역할을 수행할 것이다.  

지금까지의 전제를 바탕으로, Promising 함수를 설계해보자.  
같은 행 조건은 이미 전제로 두었으니 Promising 함수에서는 고려하지 않는다.  
이 함수에서 확인해야 할 것은 "이전 퀸과 하나라도 같은 열에 존재하는지"와 "이전 퀸과 대각선 방향에서 겹치는지"다.  
열에 관한 부분은 어렵지 않게 떠올릴 수 있지만, 대각선 방향은 그림을 그려서 생각해보는 편이 유리하다.  

<img width="442" height="424" alt="image" src="https://github.com/user-attachments/assets/4bb90f97-efd5-4200-9c0b-fb650940be76" />

좌측 상단 모서리를 (0, 0)으로, 우측 하단 모서리를 (3, 3)으로 하는 체스판을 가정하겠다.   
이 때 대각선 조건이 되는 상황을 몇 개 적어보면 다음과 같은 규칙을 발견할 수 있다.
> 두 퀸 사이의 X 좌표의 차와 Y 좌표의 차가 같다면, 두 퀸은 대각선 방향에 놓인다.

특정 노드의 가능성을 검사하는 Promising 함수는 부모 노드들을 하나씩 검사하면서, 
조건에 위배된다면 바로 False를 반환하고 모두 동선이 겹치지 않았을 때만 True를 반환하도록 구현하면 된다.

예를 들어, 기존 (0, 0)과 (1, 3) 위치에 퀸이 놓인 체스판에서 추가로 (2, 2) 위치에 퀸을 놓는다면  
(0, 0)과의 조건을 검사할 때는 무사히 통과하지만 (1, 3)과의 검사에서는 '대각선' 조건에 위배되어 False를 반환할 것이다.

```
import sys

n = int(sys.stdin.readline())
# 퀸의 위치를 저장하는 1차원 리스트. pos[i]는 i행에 있는 퀸의 열 위치를 의미.
# promising 함수에서 행에 대해 반복문을 돌기 때문에, 2차원 리스트를 사용할 필요가 없다.
pos = [0] * n 

def promising(row, col):
    """
    (row, col) 위치에 퀸을 놓아도 되는지 검사
    """
    # 현재 row 이전의 모든 행(0부터 row-1까지)을 검사
    for i in range(row):
        # (같은 열에 있는지) OR (대각선에 있는지) 검사
        if pos[i] == col or abs(pos[i] - col) == row - i:
            return False
    return True
```

이제는 재귀적으로 트리를 깊이 우선으로 탐색하면서, Promising 함수의 반환값에 따라 가지 치기 여부를 결정한다.  
일반적으로 백트래킹 문제에서는 리스트 클래스의 pop 메서드 등을 통해, 이전에 넣어둔 결과값을 없애주는 단계가 필요하지만,  
N-Queens 문제에서는 col에 대한 반복문을 돌면서, pos[row]의 값을 계속해서 덮어쓰기 때문에, 명시적인 Backtrack 로직은 불필요하다.  

```
def n_queens(row):
    """
    row번째 행부터 퀸을 놓는 함수
    """
    global count
    
    # Base Condition
    # row가 n에 도달했다는 것은, 0 ~ (n-1)까지의 모든 행에 퀸이 문제 없이 배치되었다는 것 
    if row == n:
        count += 1
        return

    # 현재 row의 모든 열(0부터 N-1)에 퀸을 놓아봄
    for col in range(n):
        # 유망한 가지들만 탐색 진행 (나머지는 탐색 없이 넘어가는 가지치기)
        if promising(row, col):
            pos[row] = col # 현재 위치에 퀸을 놓음
            
            # 재귀를 통한 깊이 우선 탐색
            n_queens(row + 1) # 다음 행으로 재귀 호출
            
            # 백트래킹
            # n_queens(row + 1)가 끝났다는 것은 pos[row] = col인 상태에서 파생된 모든 탐색이 끝났다는 의미.
            # 이제 for문은 다음 col로 넘어가서 pos[row]의 값을 다음 col 값으로 덮어쓴다.
            # 이전 선택이 자연스럽게 잊혀지기 때문에, pop() 등의 메서드가 필요 없다

n_queens(0)
print(count)
```

백트래킹의 시간 복잡도는 최악의 상황에서 (N-Queens 함수의 호출 횟수) * (각 호출에서 노드 방문 횟수) = O(N) * O(N!) = O(N!) 이지만, 
가지치기를 이용한 덕분에 실제 작동 시간은 이보다 적다.

---
Reference:  
https://youtu.be/z4wKvYdd6wM  
https://www.geeksforgeeks.org/dsa/4-queens-problem/

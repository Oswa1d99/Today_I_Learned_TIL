## 명령어 집합 (Instruction Set)

컴퓨터가 이해할 수 있는 정보는 명령어(Instruction)와 데이터(Data)이다. 
이 중 명령어의 기본적인 구조와 내부 작동 원리는 CPU에 관계없이 유사하지만, 명령어의 형태, 수행 가능한 연산, 주소 지정 방식 등에서 CPU마다 차이를 보인다.

CPU가 이해하고 실행 가능한 명령어의 모음을 명령어 집합(Instruction Set)이라고 하며, 이 명령어 집합의 설계 방식을 ISA(Instruction Set Architecture)라고 한다. 
ISA가 다른 CPU는 서로의 명령어를 이해하지 못하므로, ISA는 'CPU의 언어'로 정의될 수 있다.

---

## CISC (Complex Instruction Set Computer)

**CISC**는 '복잡한 명령어 집합을 활용하는 컴퓨터'로, Intel과 AMD의 **x86, x86-64** 아키텍처가 대표적인 예이다.

CISC는 복잡하고 강력한 기능의 명령어를 다수 포함하는 것이 특징이다.

-   **장점:**
    1.  강력한 명령어를 통해 상대적으로 **적은 수의 명령어로 프로그램을 구성**할 수 있다.
    2.  프로그램을 구성하는 명령어 수가 줄어들어, 결과적으로 **메모리 사용량을 절약**하는 장점이 있다. 이는 과거 메모리 비용이 높았던 시기에 중요한 설계 요인이었다.
-   **단점:**
    1.  명령어의 종류가 다양하고 길이가 일정하지 않은 **가변 길이 명령어**를 사용하므로, 명령어 해석(Decode) 과정이 복잡하고 시간이 소요될 수 있다.
    2.  복잡한 명령어 하나는 CPU 내부적으로 여러 개의 단순한 동작으로 나뉘어 실행되므로, **단일 명령어 실행에 다수의 클럭 사이클(Clock Cycle)이 필요**할 수 있다.

현대의 CISC 프로세서는 내부적으로 CISC 명령어를 **마이크로 오퍼레이션**이라는 RISC와 유사한 형태의 단순 명령어로 변환하여 처리한다. 
이를 통해 CISC 아키텍처에서도 RISC의 장점인 파이프라이닝 기법을 효율적으로 활용하는 것이 가능해졌다.

---

## RISC (Reduced Instruction Set Computer)

**RISC**는 명령어의 수를 줄이고, 단순하며 규격화된 명령어 집합을 갖춘 아키텍처이다. 
Apple의 M 시리즈 프로세서나 다수의 모바일 AP(Application Processor)에서 사용되는 **ARM** 아키텍처가 이에 해당한다.

-   **특징:**
    1.  명령어의 종류가 제한적이며, 모든 명령어의 길이가 동일한 **고정 길이 명령어**를 사용한다.
    2.  대부분의 명령어는 **1클럭 내외로 실행**되도록 단순하게 설계되었다.
    3.  따라서 CISC 기반의 동일 기능 프로그램보다 더 많은 수의 명령어가 요구되며, 메모리 점유율 또한 증가한다.
    4.  메모리 접근은 **`LOAD`(메모리→레지스터)**와 **`STORE`(레지스터→메모리)** 두 가지 명령어로 엄격히 제한된다.
        - 모든 산술/논리 연산은 레지스터 상에서만 수행되는데, 이를 **Load-Store 아키텍처**라 칭한다.

메모리에 위치한 두 데이터 `A`와 `B`를 더해 다시 메모리에 저장하는 연산을 예로 들면, 두 아키텍처의 차이는 다음과 같다.

-   **CISC:** `ADD A, B` 와 같은 단일 명령어로 메모리 접근과 연산을 동시에 처리할 수 있다.
-   **RISC:** 모든 연산은 레지스터에서 수행되어야 하므로, 아래와 같이 여러 단계로 분리하여 처리한다.
    > 1.  `LOAD R1, A` (메모리 A의 값을 레지스터 R1으로 로드)
    > 2.  `LOAD R2, B` (메모리 B의 값을 레지스터 R2로 로드)
    > 3.  `ADD R3, R1, R2` (R1과 R2의 값을 더해 결과를 R3에 저장)
    > 4.  `STORE C, R3` (R3의 값을 메모리 C에 저장)

이러한 RISC의 구조적 단순성은 CPU의 성능 향상 기법인 파이프라이닝(Pipelining)에서 큰 이점을 제공한다.

---

## 파이프라이닝 (Pipelining)

**파이프라이닝**은 명령어 처리 과정을 여러 단계로 분할하고, 각 단계가 독립적으로 다른 명령어를 동시에 처리하도록 하여 CPU의 전체 처리량을 높이는 기술이다.

하나의 명령어는 일반적으로 다음과 같은 **5단계**를 거쳐 실행된다.
- CISC 아키텍처는 단일 명령어(eg. ADD)가 연산(EX)과 메모리 접근(MEM)을 함께 수행하는 경우가 많다.
-   이러한 특징을 고려하여 국내의 많은 교재나 블로그에서는 파이프라인 단계를 'IF → ID → EX → WB' 로 단순화하여 서술한다.


<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/4978c646-8c76-429b-9592-704c96b85cc1" />

  
1.  **명령어 인출 (IF, Instruction Fetch):** 메모리에서 명령어를 가져온다.
2.  **명령어 해석 (ID, Instruction Decode):** 명령어를 해석하고 필요한 레지스터를 읽는다.
3.  **실행 (EX, Execute):** 산술/논리 연산을 수행한다.
4.  **메모리 접근 (MEM, Memory Access):** `LOAD` 또는 `STORE` 명령을 위해 메모리에 접근한다.
5.  **결과 저장 (WB, Write Back):** 연산 결과를 레지스터에 기록한다.

파이프라이닝이 없다면, 각 단계가 1 클럭씩 소요된다고 가정할 때 3개의 명령어를 처리하기 위해3 * 5 = 15 클럭이 필요하다. 
그러나 파이프라이닝을 적용하면, 각 단계가 겹치지 않는 선에서 동시에 실행되므로 이론적으로 첫 명령어가 완료된 이후부터는 매 클럭마다 하나의 명령어가 완료된다.

### 파이프라이닝과 RISC

RISC 아키텍처가 파이프라이닝에 유리한 이유는 명령어의 **길이가 고정**되어 있고 **구조가 단순**하여, 파이프라인의 각 단계가 소요하는 시간이 균일하기 때문이다. 
이는 파이프라인의 흐름이 지연 없이 원활하게 유지되도록 하는 핵심적인 요소이다.  

반면, CISC는 명령어의 형태와 실행 시간이 가변적이므로 파이프라인의 특정 단계에서 병목 현상이 발생할 가능성이 높다.

---

Image Reference:  
https://medium.com/@aylia.zulfiqar29/5-stages-of-pipeline-in-computer-architecture-dc9fca11784e

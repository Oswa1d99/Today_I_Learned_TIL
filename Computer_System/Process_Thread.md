## 프로세스(Process)

GUI 상에 존재하는 응용 프로그램을 사용하기 위해서는 보조기억장치에 적재된 프로그램을 운영체제가 메모리(RAM)로 로드하고 CPU에게 자원을 할당 받아야 한다.  
> 자원 : 프로그램 실행에 필요한 요소 일체 (데이터와 하드웨어 부품 모두를 의미함)  

이때, 프로그램의 실행 중인 인스턴스를 프로세스라고 한다. 하나의 응용 프로그램은 여러 개의 프로세스로 실행될 수 있는데, 대표적인 예시로 여러 개의 크롬 브라우저를 사용하는 상황이 될 수 있겠다.
> 원론적으로 하나의 크롬 브라우저는 메인 프로세스, 렌더러 프로세스 등의 여러 프로세스를 실행하기 때문에, 한 번만 실행하여도 멀티 프로세스 상태이다.  

프로세스는 운영체제에 의해 메모리 공간을 할당받는 독립적인 엔티티로, 여러 프로세스는 **서로 다른 메모리 공간**에서 실행되기 때문에 특수한 기법(IPC 혹은 공유 메모리)를 이용하여야만 다른 프로세스에 접근이 가능하다.
  
운영체제에 의해 자원을 할당받은 프로세스는 메모리의 **커널 영역**과 **사용자 영역**에 정보를 저장한다.

### 프로세스 제어 블록(PCB)
운영체제는 메모리에 적재된 여러 프로세스를 관리해야 하는데, 이를 위해서는 프로세스를 식별할 수 있는 정보가 커널 영역에 저장되어야 한다.  
PCB는 프로세스가 생성됐을 때 커널 영역에 만들어지고, 프로세스가 종료되면 PCB 또한 폐기된다.  

PCB에는 
1. 프로세스 식별 변호(PID)
2. 프로세스가 실행 과정에서 사용한 CPU 레지스터 값
    - 프로세스가 전환될 때, 기존 작업 내용을 해당 레지스터에 백업
3. 프로세스 상태 (준비, 대기 , 종료 등)
4. CPU 스케쥴링 정보
5. 메모리 관련 정보
    - 사용자 영역의 각 영역이 어디서 시작하고, 크기는 어떻게 되는지
6. 자원 할당 정보 (파일, I/O 장치 등)

정보가 담겨있다.  

새롭게 프로세스가 생성되면 PCB를 **프로세스 테이블**에 추가하고 자원을 할당한다. 반대로, 작업이 종료되면 자원을 해제하고 프로세스 테이블에서 PCB를 삭제한다.  
> 좀비 프로세스 : 프로세스가 비정상 종료되어, 자원은 해제되었지만 프로세스 테이블에 PCB가 남아있는 케이스


### 사용자 영역에 배치된 영역
다음으로, 프로세스가 할당받은 **사용자 영역**의 메모리 공간은 크게 4가지로 나뉜다.
1. **코드 영역** : 프로그래머가 작성한 코드가 CPU가 해석 가능한 기계어 형태로 저장된다.  
    - 파이썬의 경우, `.py` 내부의 텍스트가 아닌, 파이썬 가상머신(PVM)이 해석하는 바이트코드에 해당한다.  
2. **데이터 영역** : 프로그래밍 시작될 때부터 종료 시까지 유지되는 데이터를 저장한다. 대표적으로 전역 변수(클래스나 함수 바깥에서 정의된 객체)가 데이터 영역에 저장된다.  
3. **스택 영역** : 함수 호출과 관련된 임시 데이터를 저장한다.  함수 내부에서 선언된 **지역 변수, 함수의 파라미터, 함수 종료 이후 돌아갈 반환 주소**가 스택에 저장된다.  
    - 재귀 구조를 생각해보면, 특정 종료 조건에 도달하면 마지막에 실행된 재귀 함수부터 차례대로 되감듯이 실행되는데, 이는 LIFO를 따르는 스택 구조 상 자연스러운 현상이다. 
    - 에러 메시지의 Traceback은 에러 발생 시의 스택 트레이스(특정 시점에 스택에 저장된 함수 호출 정보)를 보여준다.  
4. **힙 영역** : 동적으로 데이터를 할당하고 관리하는 영역이다. 배열, 클래스, PyTorch Tensor 등 대부분의 데이터가 힙에 동적으로 할당된다. 객체를 해제할 때는 수동으로 개발자가 메모리를 해제하거나(C, C++) 혹은 가비지 컬렉터에 의해 시스템이 힙 영역을 관리한다(Python, Java).  

4가지 영역 중에서 코드 영역과 데이터 영역은 선언될 때 크기가 결정되는 정적 영역이며, 스택 영역와 힙 영역은 실행 중 크기가 변하는 동적 영역이다.  

### 컨텍스트 스위칭(Context Switching)
메모리에는 여러 프로세스가 적재되어 있기에, 하나의 프로세스가 CPU 자원을 독점하면 다른 여러 프로세스의 사용에 문제가 생긴다.  
그렇기에, 다양한 프로세스들이 **한정된 시간**동안 운영체제로부터 CPU의 자원을 번갈아가며 할당받고, 한정된 시간이 끝나면 **타임아웃 인터럽트**가 발생해 다음 프로세스에 CPU 자원을 양보하는 절차를 거치게 된다.  

타임아웃 인터럽트로 인해 프로세스의 작업이 중단될 때, CPU는 현재 프로세스의 작업 관련 정보(컨텍스트)를 PCB에 저장하고, 다음 프로세스의 컨텍스트를 불러온다.  
즉 타임아웃 인터럽트가 발생하고 즉시 다음 프로세스로 전환되는 것이 아니라, **문맥 저장과 복구라는 오버헤드가 발생**한다.  

컨텍스트 스위칭이 되면, CPU는 다음 프로세스의 명령어를 실행하기 시작하고 그 명령어에 필요한 데이터를 찾기 위해 먼저 캐시를 확인한다.  
하지만 캐시에는 이전에 실행되던 프로세스의 데이터가 남아있기 때문에, 새로운 프로세스가 필요로 하는 데이터는 대부분 **캐시 미스**를 일으킨다. 
캐시 미스가 발생하면, CPU는 메인 메모리(RAM)에서 필요한 데이터를 가져오고, 이 데이터를 캐시에 저장하는 작업을 진행한다.  
즉, 컨텍스트를 전환하면 빠르게 로드할 수 있는 캐시를 활용하기 어렵게 된다.  

오버헤드와 캐시 미스로 인해 잦은 컨텍스트 스위칭은 성능 하락을 유발하고, 이를 방지하고자 **CPU 스케쥴링** 기법 등을 통해 컨텍스트 스위칭의 빈도를 줄이고 효율성을 높인다.  

## 스레드(Thread)

<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/77d3fb08-e027-4bb3-9a21-3e8fb324e33f" />

스레드는 **하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위**를 말한다.  
하나의 프로그램은 하나 이상의 프로세스를 가지고, 각 프로세스는 반드시 **하나 이상의 스레드**를 갖는다.  
만약, 단일 스레드를 사용한다면 `main` 스레드가 생성되며, 개발자가 멀티스레드를 구현하면 그 이외의 스레드가 각각 하나의 작업 흐름을 담당하게 되는 셈이다.  

스레드는 프로세스가 할당 받은 자원을 이용하는 실행의 단위이기에, 스레드는 하나의 프로세스에 할당된 메모리 공간을 대부분 공유한다.  
프로세스의 4가지 메모리 영역 중 스레드는 고유한 **스택 영역**만을 가지고, 나머지 영역(코드, 데이터, 힙)은 다른 스레드와 공유한다.  
> 독립적인 스택을 가졌다는 것은 독립적인 함수 호출이 가능하다. 즉, 각 스레드가 개별적으로 스택 영역을 가졌기에 독립적인 함수 호출이 가능하고 이로 인해 독립적인 작업 흐름이 되는 것이다.

프로세스 간에는 별도의 통신 메커니즘을 활용해 통신해야 하기에 오버헤드가 발생한다. 하지만, 스레드 간 통신은 메모리 내에서 이뤄지기에 여러 스레드가 데이터를 직접 접근하기에 편리하고 스레드 간 데이터 이동도 자유롭다.  
또한, 각 스레드는 대부분의 메모리 영역을 공유하기에 프로세스에 비해 훨씬 적은 시스템 자원만을 차지한다.

스레드가 가지는 이점이 동시에 단점으로 이어진다. 데이터와 힙 영역을 공유하기 때문에 하나의 스레드에서 오류가 발생하면, 다른 스레드에게 영향을 미치고 이로 인해 전체 프로세스가 오작동을 일으킬 수 있다. 스레드가 공유 자원에 접근하면서 생기는 문제를 **동기화**라고 일컫는데, 멀티스레드에서 동기화 문제를 해결하기 위해 다양한 기법이 존재한다.

---

### Reference
- https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4 
